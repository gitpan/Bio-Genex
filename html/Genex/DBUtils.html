<HTML>
<HEAD>
<TITLE>DBUtils - a module for useful Database utilities</TITLE>
<LINK REV="made" HREF="mailto:jasons@amadeus.avesthagen.com">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#functions">FUNCTIONS</A></LI>
	<LI><A HREF="#author">AUTHOR</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>DBUtils - a module for useful Database utilities</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
  use DBUtils;</PRE>
<PRE>
  assert_table_defined($dbh,$table_name);</PRE>
<PRE>
  assert_dbh($dbh);</PRE>
<PRE>
  $id = fetch_last_id($dbh,$table_name);</PRE>
<PRE>
  $sql_string = create_insert_sql($dbh,$table_name,@column_names);</PRE>
<PRE>
  $sql_string = create_update_sql($dbh,$table_name,
                                  SET=&gt;$array_ref,WHERE=&gt;$string);</PRE>
<PRE>
  $sql_string = create_select_sql($dbh,
                                  COLUMNS=&gt;$array_ref,
                                  FROM=&gt;$array_ref,
                                  WHERE=&gt;$where_string,
                                  DISTINCT=&gt;$bool,
                                  LIMIT=&gt;$bool,
                                 );</PRE>
<PRE>
  $species = fetch_es_species($es_pk);</PRE>
<PRE>
  @ids = fetch_es_ids();</PRE>
<PRE>
  @ids = fetch_user_al_ids($us_fk);</PRE>
<PRE>
  @ids = fetch_am_ids($experiment_set_pk, 
                      @array_measurement_types);</PRE>
<PRE>
  $array_ref = fetch_fkey_list($dbh,
                               $table_name,
                               $column_name,
                               $pkey,
                               $rec_level);</PRE>
<PRE>
  $exp_set = fetch_spot_data($es_pk,@am_types);</PRE>
<PRE>
  output_spot_data($file_handle,
                   $experiment_set_pk,
                   @array_measurement_types);</PRE>
<PRE>
  $id = lookup_id($dbh,$table,$attribute,$value,$approx);</PRE>
<PRE>
  $id = lookup_species_id($dbh,$species_name,$approx);</PRE>
<PRE>
  $id = lookup_usf_id($dbh,$usf_name,$approx);</PRE>
<PRE>
  $id = lookup_contact_id($dbh,$contact_name,$approx);</PRE>
<PRE>
  $id = lookup_software_id($dbh,$software_name,$approx);</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>Helper functions for achieving common DB tasks with a GeneX DB.</P>
<P>
<HR>
<H1><A NAME="functions">FUNCTIONS</A></H1>
<DL>
<DT><STRONG><A NAME="item_create_update_sql">create_update_sql($dbh,TABLE=&gt;$table,SET=&gt;$hash_ref,WHERE=&gt;$string)</A></STRONG><BR>
<DD>
Returns an SQL string valid for the current DBMS. It is up to the
caller whether to use DBI placeholders or not, they will not be
generated by the subroutine.
<P></P>
<DT><STRONG><A NAME="item_create_insert_sql"><CODE>create_insert_sql($dbh,$table,\@column_names)</CODE></A></STRONG><BR>
<DD>
<DT><STRONG><CODE>create_insert_sql($dbh,$table,\%col_val_pairs)</CODE></STRONG><BR>
<DD>
There are two methods of invoking create_insert_sql. If invoked with
only an array reference of column names, create_insert_sql will return
an SQL string with placeholders for use by the DBI <CODE>prepare()</CODE> and
<CODE>exectute()</CODE> methods. In this case the <CODE>\@columen_name</CODE> reference
contains the names and order of the columns we plan to insert data in
<CODE>$table</CODE>.
<P>If invoked with a hash reference of column name/value pairs,
create_insert_sql will return a final SQL string that can be used by
DBI <CODE>do()</CODE>.</P>
<P></P>
<DT><STRONG><A NAME="item_create_select_sql">create_select_sql($dbh,
           COLUMNS=&gt;$array_ref, 
           FROM=&gt;$array_ref, 
           WHERE=&gt;$string, 
           DISTINCT=&gt;$bool, 
           LIMIT=&gt;$integer)</A></STRONG><BR>
<DD>
Takes an array reference of column names to select from an array
reference of table names used in the FROM clause, a string WHERE
clause, and a boolean DISTINCT flag and returns a SQL string to fetch
the requested data. A LIMIT clause will be added if the LIMIT
parameter is specified.
<P><STRONG>Return value</STRONG>: an SQL string that is specific to the driver for
$dbh (currently this is only implemented for PostgeSQL).</P>
<P></P>
<DT><STRONG><A NAME="item_lookup_usf_id"><CODE>lookup_usf_id($dbh,$sequence_feature_name,$approx)</CODE></A></STRONG><BR>
<DD>
Given a sequence feature name, this function returns the primary key
in the DB for that sequence feature.
<P>If the optional <CODE>$approx</CODE> flag is specified, then <A HREF="#item_lookup_usf_id"><CODE>lookup_usf_id()</CODE></A>
will use wildcarding around <CODE>$sequenc_feature_name</CODE> so the name does not have
to be an exact match.</P>
<P></P>
<DT><STRONG><A NAME="item_assert_dbh"><CODE>assert_dbh($dbh)</CODE></A></STRONG><BR>
<DD>
This method ensures that $dbh is a valid instance of class
Bio::Genex::Connect, otherwise it triggers an exception.
<P></P>
<DT><STRONG><A NAME="item_assert_table_defined"><CODE>assert_table_defined($dbh,$table_name)</CODE></A></STRONG><BR>
<DD>
This ensures that $table_name exists in $dbh, otherwise it triggers an
exception. This method caches its results for all tables it finds for
$dbh. This significantly speeds up all future calls for all tables.
<P></P>
<DT><STRONG><A NAME="item_lookup_contact_id"><CODE>lookup_contact_id($dbh,$contact_name,$approx)</CODE></A></STRONG><BR>
<DD>
Given a contact person name, this function returns the primary key
in the DB for that contact.
<P>If the optional <CODE>$approx</CODE> flag is specified, then <A HREF="#item_lookup_contact_id"><CODE>lookup_contact_id()</CODE></A>
will use wildcarding around <CODE>$contact_name</CODE> so the name does not have
to be an exact match.</P>
<P></P>
<DT><STRONG><A NAME="item_lookup_software_id"><CODE>lookup_software_id($dbh,$software_name,$approx)</CODE></A></STRONG><BR>
<DD>
Given a software name, this function returns the primary key
in the DB for that software.
<P>If the optional <CODE>$approx</CODE> flag is specified, then <A HREF="#item_lookup_software_id"><CODE>lookup_software_id()</CODE></A>
will use wildcarding around <CODE>$software_name</CODE> so the name does not have
to be an exact match.</P>
<P></P>
<DT><STRONG><A NAME="item_lookup_species_id"><CODE>lookup_species_id($dbh,$species_name,$approx)</CODE></A></STRONG><BR>
<DD>
Given a primary scientific name, this function returns the primary key
in the DB for that species.
<P>If the optional <CODE>$approx</CODE> flag is specified, then <A HREF="#item_lookup_species_id"><CODE>lookup_species_id()</CODE></A>
will use wildcarding around <CODE>$species_name</CODE> so the name does not have
to be an exact match.</P>
<P></P>
<DT><STRONG><A NAME="item_lookup_experiment_id"><CODE>lookup_experiment_id($dbh,$experiment_name)</CODE></A></STRONG><BR>
<DD>
Given an experiment set name, this function returns the primary key
in the DB for that experiment set.
<P>If the optional <CODE>$approx</CODE> flag is specified, then <A HREF="#item_lookup_experiment_id"><CODE>lookup_experiment_id()</CODE></A>
will use wildcarding around <CODE>$experiment_name</CODE> so the name does not have
to be an exact match.</P>
<P></P>
<DT><STRONG><A NAME="item_lookup_id"><CODE>lookup_id($dbh,$table,$attribute,$pk_name,$value,$approx)</CODE></A></STRONG><BR>
<DD>
Retrieves the primary key ($pk_name) for a row in $table whose
$attribute column is $value).
<P>The optional $approx flag species that approximate mathcing using an
SQL 'LIKE' clause should used instead of exact matching using '='.</P>
<P></P>
<DT><STRONG><A NAME="item_fetch_last_id"><CODE>fetch_last_id($dbh,$table)</CODE></A></STRONG><BR>
<DD>
Retrieves the primary key of the last row inserted into $table.
<P></P>
<DT><STRONG><A NAME="item_check_password"><CODE>check_password($dbh,$user_name,$password)</CODE></A></STRONG><BR>
<DD>
Checks whether there exists an entry in the UserSec table whose
'login' == $user_name and 'password' == $password.
<P>Return value: 
  On Success: the primary key of the UserSec entry
  On Failure: undef</P>
<P></P>
<DT><STRONG><A NAME="item_fetch_es_ids"><CODE>fetch_es_ids()</CODE></A></STRONG><BR>
<DD>
Retrieves the primary keys of all experiment sets in the DB.
<P></P>
<DT><STRONG><A NAME="item_fetch_am_ids">fetch_am_ids($es_pk, @am_types)</A></STRONG><BR>
<DD>
Retrieves the primary keys of all array measurements belonging to
experiment set $es_pk.
<P>The optional @am_types list is used to filter the arrays to a given
type. There is no default value for this parameter.</P>
<P>Return Value:
   list of ArrayMeasurement ids or undef if none.</P>
<P></P>
<DT><STRONG><A NAME="item_fetch_spot_data"><CODE>fetch_spot_data($es_pk,@am_types)</CODE></A></STRONG><BR>
<DD>
Fetches all spot data from AM_Spots for all arrays of ExperimentSet $es_pk.
<P>The optional @am_types list will restrict the retrieval to only arrays
of the specified types, the default value of @am_types is
('derived ratio').</P>
<P><STRONG>Return value</STRONG>: an instance of <CODE>Bio::Genex::ExperimentSet</CODE></P>
<P>Example use:</P>
<PRE>
  use Bio::Genex::DBUtils qw(fetch_spot_data, fetch_es_ids)
  my @es_ids = fetch_es_ids();
  foreach my $es_pk (@es_ids) {
    my $es = fetch_spot_data($es_pk);
    my @array_list = $es-&gt;arraymeasurement_fk();
    foreach my $array (@array_list) {
      my $spot_list_ref = $array-&gt;am_spots_fk();</PRE>
<PRE>
      # locate the column for the spot values
      my @header = shift @{$spot_list_ref};
      my $spot_col;
      my $usf_col;
      for (my $i=0;$i&lt;scalar @header;$i++) {
        $spot_col = $i if $header[$i] =~ /spot_value/;
        $usf_col = $i if $header[$i] =~ /usf_fk/;
      }
      die &quot;Couldn't find columns for &quot; . $array-&gt;name() 
        unless defined $spot_col &amp;&amp; defined $usf_col;
</PRE>
<PRE>

      foreach my $spot (@{$spot_list_ref}) {
        print &quot;$spot-&gt;[$usf_col]\t$spot-&gt;[$spot_col]&quot;;
      }
    }
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_output_spot_data">output_spot_data($file_handle, $es_pk, @am_types)</A></STRONG><BR>
<DD>
Writes all of the spot data belonging to experiement set $es_pk, to
$file_handle.
<P>The optional @am_types list is used to filter the spot data belonging
to only arrays of the given types. The default value is
<CODE>('derived ratio')</CODE>.</P>
<P></P>
<DT><STRONG><A NAME="item_fetch_fkey_list">fetch_fkey_list(dbh=&gt;$dbh,calling_class=&gt;$table_name,class_to_fetch=&gt;$table_name,column_to_fetch=&gt;$column_name,value_to_fetch=&gt;$pkey)</A></STRONG><BR>
<DD>
<STRONG>Parameters:</STRONG> <CODE>dbh</CODE>: a database handle; <CODE>calling_class</CODE>: the name
of the class requesting the data; <CODE>class_to_fetch</CODE> the name of the
table to lookup the data from; <CODE>column_to_fetch</CODE>: the name of foreign
key in <CODE>class_to_fetch</CODE> that refers to <CODE>calling_class</CODE>;
<CODE>value_to_fetch</CODE>: the value of <CODE>column_to_fetch</CODE> to use in the
<CODE>WHERE</CODE> clause.
<P><STRONG>Control Variables:</STRONG> Setting <CODE>$Bio::Genex::DBUtils::NO_FETCH_DISTINCT</CODE>
instructs fetch_fkey_list to not use the <CODE>DISTINCT</CODE> SQL keyword in
the query (the default is to use <CODE>DISTINCT</CODE>. Setting
<CODE>$Bio::Genex::DBUtils::NO_FETCH_ALL</CODE> instructs the method to not set the
<CODE>fetch_all</CODE> parameter when calling <CODE>new()</CODE> on each object (the
default is to use <CODE>fetch_all</CODE>).</P>
<P></P>
<DT><STRONG><A NAME="item_fetch_user_al_ids"><CODE>fetch_user_al_ids($us_fk)</CODE></A></STRONG><BR>
<DD>
Find all ArrayLayouts for a given user.
<P>Return Value:
   a list of ArrayLayout ids or undef if none.</P>
<P></P>
<DT><STRONG><A NAME="item_fetch_es_species"><CODE>fetch_es_species($es_pk)</CODE></A></STRONG><BR>
<DD>
Parameters: $es_pk, the primary key for the ExperimentSet whose species are 
being queried.
<P>Return value: an instance of class <CODE>Bio::Genex::Species</CODE>.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>Jason Stewart (<A HREF="mailto:jes@ncgr.org">jes@ncgr.org</A>), and Peter Hraber (<A HREF="mailto:pth@ncgr.org">pth@ncgr.org</A>)</P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P>perl(1).</P>

</BODY>

</HTML>
